# 程序内存分配
1. 栈 (stack)  
   - 编译器自动存放，存放函数的参数值，局部变量值等  
   - 先进后出， First in Last out
   - 从高地址向低地址生长
2. 堆 (heap)  
   - 一般由程序员分配释放
   - c语言使用`stdlib.h`里的`malloc()`函数分配，使用`free()`释放  
   - c++使用`new`分配，`delete`释放
   - 由低地址向高地址生长
3. 全局区 (static)  
   - 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 
   - 程序结束后有系统释放
4. 文字常量区  
   - 常量字符串
5. 程序代码区

```c
int a = 0; //全局初始化区
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main() {
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);
    //分配得来得10和20字节的区域就在堆区。
    strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}
```
# 野指针出现的可能以及规避方法
- 可能出现的原因  
  1. 未初始化指针
   ```c
   int *p;
   *p = 10;
   ```
   2. 内存释放之后还继续使用
   ```c
   int *p = malloc(sizeof(int));
   free(p);
   *p = 10;
   ```
   3. 返回了局部变量地址
   ```c
   int func(void)
   {
      int x = 10;
      return &x;
   }
   ```
   4. 数组越界 / 指针运算越界
   ```c
   int arr[3] = {1, 2, 3};
   int *p = arr + 5;
   ```
   5. 释放指针之后没有赋值为`NULL`,再次`free`会变成野指针
- 规避方法
  1. 注意以上几点
  2. 使用`Valgrind`检查内存泄漏

# 分析程序
```c
int main()
 {
   int arr[5] = { 1, 2, 3, 4, 5};
   int* ptr1 = (int*)(&arr + 0x1);
   int* ptr2 = (int*)((long long)arr + 0x1);
   printf("%x,%x", ptr1[-1], *ptr2);
   return 0;
 }
```
```c
   int* ptr1 = (int*)(&arr + 0x1);
```  
- `arr`类型是`int[5]`，一般情况下会衰减为`int *`，即指向首个元素的`int`指针，但是有两个特例
  1. 本程序情况，即`&arr`，这时候`&arr`得到的是指向整个数组的指针
  2. `sizeof(arr)`返回的将是20(5 * `sizeof(int)`)
- `&arr + 0x1` 是指向整个数组的指针加一，相当于地址向高位偏移20
- `(int *)`强制转换其为整数指针
- `ptr[-1]`相当于`*(ptr - 1)`,但此时是`int *`类型，会自动cast为减去四个字节
- 20 - 4 = 16，相当于从数组首地址向高位偏移16，也就是原来数组第四个元素，输出结果是5
```c
int* ptr2 = (int*)((long long)arr + 0x1);
```
- `(long long)`强制转换到`long long`一种整形，转换为数组首地址
- 这时候， 由于`(long long) arr`是一个整形，加`0x1`就是算术上加一
- `(int *)`强制转换为int指针，这时候是指向数组首地址向高位偏移一个字节的结果(考虑小端存储)  
arr[0] 01 *00* *00* *00*     
arr[1] *02* 00 00 00  
偏移一个字节正好是02 00 00 00
# enum vs #define
 1. #define是预处理宏，在预处理阶段直接替换，调试的时候看不到名字
 ```c
 #define RED 0
 #define GREEN 1
 #define BLUE 2
 ```
 2. enum编译时是常量，int类型，调试的时候可以看到名字
 ```c
 enum Color
 {
    RED，
    Bule，
    Green,
 }
 ```

